












#ifdef __APPLE__
	if (fl_xfocus != win) {
	  Fl_X *x = Fl_X::i(win);
	  if (x) x->set_key_window();
	}
#elif defined(USE_X11)
	if (fl_xfocus != win) {
	  Fl_X *x = Fl_X::i(win);
	  if (!Fl_X::ewmh_supported())
	    win->show(); // Old WMs, XMapRaised
	  else if (x) // New WMs use the NETWM attribute:
	    Fl_X::activate_window(x->xid);
	}
#endif

#if defined(USE_X11)

#if defined(DEBUG) || defined(DEBUG_WATCH)
#  include <stdio.h>
#endif // DEBUG || DEBUG_WATCH

#ifdef WIN32

#elif defined(__APPLE__)
#endif // WIN32

#include <sys/time.h>

#if defined(WIN32) && !defined(__CYGWIN__)
#  include <winsock2.h>
#endif
#ifdef WIN32
  

	@list=\'$(SUBDIRS)\'; for subdir in $list; do \
	$(make -C $$subdir) \
	done 

    SUBDIRS := src
    TARGET := app
    export LIB_PATH := $(strip $(CURDIR)/lib) #export传递变量给子Make,实际上就是lib的绝对路径
    export CCG := gcc #编译版本传递给子Make

    all:
        @list=\'$(SUBDIRS)\'; for subdir in $$list; do \\
        echo \"Making all in $$list\"; \\
        (cd $$subdir && make all); \\
        done
        
    .PHONY: clean
    clean:
        @list=\'$(SUBDIRS)\'; for subdir in $$list; do \\
        $(RM) $(TARGET) *.o *.d \\
        echo \"Clean in $$subdir\"; \\
        (cd $$subdir && make clean); \\
        done



    echo $(SUBDIRS)
	for x in $(SUBDIRS); do \
	  echo $x; \
	  make -C $(x); \
	done

#    @echo Making clean  
#    @list='$(SUBDIRS)'; for subdir in $$list; do \  
#        echo "Clean in $$subdir";\  
#        $(MAKE) -C $$subdir clean;\  
#    done  


//Fl_Group *g = new Fl_Group(10, 20, 80, 20);
  //g->box(FL_NO_BOX);
  //Fl_Button *b = new Fl_Button(10, 20, 80, 20, "Close");
  //b->callback(cb);
  //g->end();
  //g->resizable(NULL);
  // Fl_Group *g = new Fl_Group(60, 70, 80, 40, "Drag me");
  //g->box(FL_NO_BOX);
  //g->align(FL_ALIGN_TOP);
  //Fl_Button *bs = new Fl_Button(60, 70, 80, 20, "Shrink");
  //bs->callback(shrink, &dim);
  //bs->deactivate();
  //Fl_Button *be = new Fl_Button(60, 90, 80, 20, "Enlarge");
  //be->callback(enlarge, bs);
  //g->end();
  //g->resizable(NULL);

void drawString(const char* str) //屏幕显示字体  
{  
    static int isFirstCall = 1;  
    static GLuint lists;  
  
    if (isFirstCall) {  
        isFirstCall = 0;  
        // 申请MAX_CHAR个连续的显示列表编号  
        lists = glGenLists(260);  
        // 把每个字符的绘制命令都装到对应的显示列表中  
        glUseFontBitmaps(glGetCurrentDC(), 0, 260, lists);  
    }  
    // 调用每个字符对应的显示列表，绘制每个字符  
    for (; *str != '\0'; ++str) {  
        glCallList(lists + *str);  
    }  
}

void cube_box::draw() {
    glColor3f(0.0f, 0.0f, 0.0f);     //设置字体颜色  
    glRasterPos2i(0, winHeight-15);  //起始位置  
    drawString("  Hello，OpenGL.");   //输出的字符串  
      
    glutSwapBuffers();            //交换前后缓存区   
}

    glutInit(&argc,argv);
    glutInitDisplayMode(GLUT_DEPTH|GLUT_SINGLE|GLUT_RGB);
    //glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);  
    glClearColor(0.0, 0.0 , 0.0, 0.0);//设置背景颜色为黑色  
    glShadeModel(GL_FLAT);  
glutInitWindowPosition(100,100);
glutInitWindowSize(320,320);
glutCreateWindow("3D Tech- GLUT Tutorial");
//glutDisplayFunc(renderScene);
glutMainLoop();
